// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgGameDef.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "MsgGameDef.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace MsgPB {

namespace {

const ::google::protobuf::Descriptor* MsgPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgSize_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgSize_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgArea_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgArea_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgCircle_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgCircle_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgGateTarget_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgGateTarget_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyVal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyVal_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyValI64_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyValI64_reflection_ = NULL;
const ::google::protobuf::Descriptor* AttrEffect_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AttrEffect_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnderAttack_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnderAttack_reflection_ = NULL;
const ::google::protobuf::Descriptor* ItemReward_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ItemReward_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgRepeatedUUID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgRepeatedUUID_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* E_ErrorCode_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ITEM_SUBTYPE_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EQUIP_TYPE_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ARMOR_EQUIP_POS_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ROLE_EFFECT_TYPE_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* SKILL_STATUS_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* SURVIVAL_GAME_RESULT_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PROTECTOR_STATUS_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PROTECTOR_LESS_THAN_REQUIRED_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PROTECTOR_WAIT_TYPE_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* MEDICAMENT_TYPE_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ACHIEVE_STATUS_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* MAIL_STATUS_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* QUALITY_GRADE_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* QUALITY_GRADE_FOR_DB_SETTING_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ITEM_CURRENCY_TYPE_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* MSG_MOVE_DIR_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* MSG_MOVE_STAT_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* E_AntiqueQuality_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* E_AntiqueIntegrity_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EN_FUNCTION_LOCK_BIT_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EN_PLAYER_EVENT_TYPE_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* GAME_NEWS_TYPE_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_MsgGameDef_2eproto() {
  protobuf_AddDesc_MsgGameDef_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "MsgGameDef.proto");
  GOOGLE_CHECK(file != NULL);
  MsgPoint_descriptor_ = file->message_type(0);
  static const int MsgPoint_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgPoint, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgPoint, y_),
  };
  MsgPoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgPoint_descriptor_,
      MsgPoint::default_instance_,
      MsgPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgPoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgPoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgPoint));
  MsgSize_descriptor_ = file->message_type(1);
  static const int MsgSize_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgSize, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgSize, height_),
  };
  MsgSize_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgSize_descriptor_,
      MsgSize::default_instance_,
      MsgSize_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgSize, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgSize, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgSize));
  MsgArea_descriptor_ = file->message_type(2);
  static const int MsgArea_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgArea, left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgArea, top_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgArea, right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgArea, bottom_),
  };
  MsgArea_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgArea_descriptor_,
      MsgArea::default_instance_,
      MsgArea_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgArea, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgArea, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgArea));
  MsgCircle_descriptor_ = file->message_type(3);
  static const int MsgCircle_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCircle, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCircle, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCircle, radius_),
  };
  MsgCircle_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgCircle_descriptor_,
      MsgCircle::default_instance_,
      MsgCircle_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCircle, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCircle, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgCircle));
  MsgGateTarget_descriptor_ = file->message_type(4);
  static const int MsgGateTarget_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgGateTarget, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgGateTarget, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgGateTarget, mapid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgGateTarget, gateid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgGateTarget, pos_),
  };
  MsgGateTarget_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgGateTarget_descriptor_,
      MsgGateTarget::default_instance_,
      MsgGateTarget_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgGateTarget, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgGateTarget, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgGateTarget));
  KeyVal_descriptor_ = file->message_type(5);
  static const int KeyVal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyVal, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyVal, val_),
  };
  KeyVal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyVal_descriptor_,
      KeyVal::default_instance_,
      KeyVal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyVal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyVal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyVal));
  KeyValI64_descriptor_ = file->message_type(6);
  static const int KeyValI64_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValI64, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValI64, val_),
  };
  KeyValI64_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyValI64_descriptor_,
      KeyValI64::default_instance_,
      KeyValI64_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValI64, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValI64, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyValI64));
  AttrEffect_descriptor_ = file->message_type(7);
  static const int AttrEffect_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AttrEffect, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AttrEffect, values_),
  };
  AttrEffect_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AttrEffect_descriptor_,
      AttrEffect::default_instance_,
      AttrEffect_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AttrEffect, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AttrEffect, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AttrEffect));
  UnderAttack_descriptor_ = file->message_type(8);
  static const int UnderAttack_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnderAttack, mapobjectid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnderAttack, damage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnderAttack, criticl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnderAttack, currhp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnderAttack, targetskill_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnderAttack, durability_),
  };
  UnderAttack_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnderAttack_descriptor_,
      UnderAttack::default_instance_,
      UnderAttack_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnderAttack, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnderAttack, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnderAttack));
  ItemReward_descriptor_ = file->message_type(9);
  static const int ItemReward_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemReward, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemReward, itemcount_),
  };
  ItemReward_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ItemReward_descriptor_,
      ItemReward::default_instance_,
      ItemReward_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemReward, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemReward, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ItemReward));
  MsgRepeatedUUID_descriptor_ = file->message_type(10);
  static const int MsgRepeatedUUID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRepeatedUUID, uuid_),
  };
  MsgRepeatedUUID_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgRepeatedUUID_descriptor_,
      MsgRepeatedUUID::default_instance_,
      MsgRepeatedUUID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRepeatedUUID, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRepeatedUUID, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgRepeatedUUID));
  E_ErrorCode_descriptor_ = file->enum_type(0);
  ITEM_SUBTYPE_descriptor_ = file->enum_type(1);
  EQUIP_TYPE_descriptor_ = file->enum_type(2);
  ARMOR_EQUIP_POS_descriptor_ = file->enum_type(3);
  ROLE_EFFECT_TYPE_descriptor_ = file->enum_type(4);
  SKILL_STATUS_descriptor_ = file->enum_type(5);
  SURVIVAL_GAME_RESULT_descriptor_ = file->enum_type(6);
  PROTECTOR_STATUS_descriptor_ = file->enum_type(7);
  PROTECTOR_LESS_THAN_REQUIRED_descriptor_ = file->enum_type(8);
  PROTECTOR_WAIT_TYPE_descriptor_ = file->enum_type(9);
  MEDICAMENT_TYPE_descriptor_ = file->enum_type(10);
  ACHIEVE_STATUS_descriptor_ = file->enum_type(11);
  MAIL_STATUS_descriptor_ = file->enum_type(12);
  QUALITY_GRADE_descriptor_ = file->enum_type(13);
  QUALITY_GRADE_FOR_DB_SETTING_descriptor_ = file->enum_type(14);
  ITEM_CURRENCY_TYPE_descriptor_ = file->enum_type(15);
  MSG_MOVE_DIR_descriptor_ = file->enum_type(16);
  MSG_MOVE_STAT_descriptor_ = file->enum_type(17);
  E_AntiqueQuality_descriptor_ = file->enum_type(18);
  E_AntiqueIntegrity_descriptor_ = file->enum_type(19);
  EN_FUNCTION_LOCK_BIT_descriptor_ = file->enum_type(20);
  EN_PLAYER_EVENT_TYPE_descriptor_ = file->enum_type(21);
  GAME_NEWS_TYPE_descriptor_ = file->enum_type(22);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_MsgGameDef_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgPoint_descriptor_, &MsgPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgSize_descriptor_, &MsgSize::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgArea_descriptor_, &MsgArea::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgCircle_descriptor_, &MsgCircle::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgGateTarget_descriptor_, &MsgGateTarget::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyVal_descriptor_, &KeyVal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyValI64_descriptor_, &KeyValI64::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AttrEffect_descriptor_, &AttrEffect::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnderAttack_descriptor_, &UnderAttack::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ItemReward_descriptor_, &ItemReward::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgRepeatedUUID_descriptor_, &MsgRepeatedUUID::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_MsgGameDef_2eproto() {
  delete MsgPoint::default_instance_;
  delete MsgPoint_reflection_;
  delete MsgSize::default_instance_;
  delete MsgSize_reflection_;
  delete MsgArea::default_instance_;
  delete MsgArea_reflection_;
  delete MsgCircle::default_instance_;
  delete MsgCircle_reflection_;
  delete MsgGateTarget::default_instance_;
  delete MsgGateTarget_reflection_;
  delete KeyVal::default_instance_;
  delete KeyVal_reflection_;
  delete KeyValI64::default_instance_;
  delete KeyValI64_reflection_;
  delete AttrEffect::default_instance_;
  delete AttrEffect_reflection_;
  delete UnderAttack::default_instance_;
  delete UnderAttack_reflection_;
  delete ItemReward::default_instance_;
  delete ItemReward_reflection_;
  delete MsgRepeatedUUID::default_instance_;
  delete MsgRepeatedUUID_reflection_;
}

void protobuf_AddDesc_MsgGameDef_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020MsgGameDef.proto\022\005MsgPB\" \n\010MsgPoint\022\t\n"
    "\001x\030\001 \001(\005\022\t\n\001y\030\002 \001(\005\"(\n\007MsgSize\022\r\n\005width\030"
    "\001 \001(\005\022\016\n\006height\030\002 \001(\005\"C\n\007MsgArea\022\014\n\004left"
    "\030\001 \001(\005\022\013\n\003top\030\002 \001(\005\022\r\n\005right\030\003 \001(\005\022\016\n\006bo"
    "ttom\030\004 \001(\005\"1\n\tMsgCircle\022\t\n\001x\030\001 \001(\005\022\t\n\001y\030"
    "\002 \001(\005\022\016\n\006radius\030\003 \001(\005\"f\n\rMsgGateTarget\022\n"
    "\n\002id\030\001 \001(\005\022\014\n\004type\030\002 \001(\005\022\r\n\005mapId\030\003 \001(\005\022"
    "\016\n\006gateid\030\004 \001(\005\022\034\n\003pos\030\005 \001(\0132\017.MsgPB.Msg"
    "Point\"\"\n\006KeyVal\022\013\n\003key\030\001 \001(\005\022\013\n\003val\030\002 \001("
    "\005\"%\n\tKeyValI64\022\013\n\003key\030\001 \001(\003\022\013\n\003val\030\002 \001(\005"
    "\"R\n\nAttrEffect\022%\n\004type\030\001 \001(\0162\027.MsgPB.ROL"
    "E_EFFECT_TYPE\022\035\n\006values\030\002 \003(\0132\r.MsgPB.Ke"
    "yVal\"|\n\013UnderAttack\022\023\n\013mapobjectid\030\001 \001(\005"
    "\022\016\n\006damage\030\002 \001(\005\022\017\n\007criticl\030\003 \001(\005\022\016\n\006cur"
    "rhp\030\004 \001(\005\022\023\n\013targetSkill\030\005 \001(\005\022\022\n\ndurabi"
    "lity\030\006 \001(\005\"/\n\nItemReward\022\016\n\006ItemID\030\001 \001(\005"
    "\022\021\n\tItemCount\030\002 \001(\005\"\037\n\017MsgRepeatedUUID\022\014"
    "\n\004uuid\030\001 \001(\003*\227\r\n\013E_ErrorCode\022\016\n\nEC_Succe"
    "ss\020\000\022\013\n\007EC_Fail\020\001\022\021\n\rEC_PacketFull\020\002\022\017\n\013"
    "EC_LackCost\020\003\022\023\n\017EC_ItemNotExist\020\004\022#\n\035EC"
    "_ItemUpgradeResult_NotExist\020\211\225\006\022#\n\035EC_It"
    "emUpgradeResult_LackItem\020\212\225\006\022!\n\033EC_ItemU"
    "pgradeResult_Cannot\020\213\225\006\022\036\n\030EC_ItemUpgrad"
    "eResult_Max\020\214\225\006\022 \n\032EC_NpcAutoIncome_Lock"
    "Biome\020\321\206\003\022(\n\"EC_NpcAutoIncome_ProtectorN"
    "otFound\020\322\206\003\022&\n EC_NpcAutoIncome_PassStag"
    "eByMail\020\323\206\003\022!\n\033EC_NpcAutoIncome_PacketFu"
    "ll\020\324\206\003\022$\n\036EC_NpcAutoIncome_FenceNotFound"
    "\020\332\206\003\022$\n\036EC_NpcAutoIncome_ItemNotEnough\020\333"
    "\206\003\022$\n\036EC_NpcAutoIncome_IndexNotFound\020\335\206\003"
    "\022$\n\036EC_NpcAutoIncome_PlantNotFound\020\336\206\003\022 "
    "\n\032EC_NpcAutoIncome_FenceLock\020\337\206\003\022\037\n\031EC_N"
    "pcAutoIncome_PlotLock\020\340\206\003\022\"\n\034EC_NpcAutoI"
    "ncome_FenceUnlock\020\341\206\003\022!\n\033EC_NpcAutoIncom"
    "e_PlotUnlock\020\342\206\003\022%\n\037EC_RefiningMine_SetI"
    "temNumError\020\203\207\003\022&\n EC_RefiningMine_SetIt"
    "emTypeError\020\204\207\003\022&\n EC_RefiningMine_SetIt"
    "emNotEnough\020\205\207\003\022#\n\035EC_RefiningMine_SetIn"
    "dexError\020\206\207\003\022%\n\037EC_RefiningMine_SetItemT"
    "ypeDiff\020\207\207\003\022 \n\032EC_RefiningMine_PacketFul"
    "l\020\210\207\003\022\036\n\030EC_SpinStartResult_Spins\020\341\324\003\022!\n"
    "\033EC_SpinStartResult_Backpack\020\342\324\003\022\'\n!EC_P"
    "vpSquadPairResult_NpcNotExist\020\305\325\003\022\'\n!EC_"
    "PvpSquadPairResult_PetNotExist\020\306\325\003\022%\n\037EC"
    "_PvpSquadPairResult_LackCount\020\307\325\003\022$\n\036EC_"
    "ProtectorResult_NpcNotExist\020\251\326\003\022\'\n!EC_Pr"
    "otectorResult_RebornLackCost\020\252\326\003\022,\n&EC_N"
    "pcPetBountyRefreshResult_LackMoney\020\331\252\004\022-"
    "\n\'EC_NpcPetBountyConfigResult_NpcNotExis"
    "t\020\301\262\004\022-\n\'EC_NpcPetBountyConfigResult_Pet"
    "NotExist\020\302\262\004\022+\n%EC_NpcPetBountyConfigRes"
    "ult_LackCount\020\303\262\004\022\035\n\027EC_PvpSquad_SystemE"
    "rror\020\351\370\004\022$\n\036EC_PvpSquad_EnemyAlreadyBatt"
    "le\020\352\370\004\022 \n\032EC_PvpSquad_SeasonNotStart\020\363\370\004"
    "\022$\n\036EC_PvpSquad_PlayerAlreadyMatch\020\364\370\004\022 "
    "\n\032EC_PvpSquad_PlayerBattling\020\365\370\004\022#\n\035EC_P"
    "vpSquad_PlayerNotMatching\020\366\370\004\022#\n\035EC_PvpS"
    "quad_UploadBatResError\020\375\370\004\022#\n\035EC_PvpSqua"
    "d_PlayerNotBattling\020\376\370\004\022%\n\037EC_PvpSquad_P"
    "layerAlreadyBattle\020\377\370\004*\207\007\n\014ITEM_SUBTYPE\022"
    "\027\n\023ITEM_SUBTYPE_NORMAL\020\000\022\032\n\026ITEM_SUBTYPE"
    "_FURNITURE\020\001\022\026\n\022ITEM_SUBTYPE_ARMOR\020\002\022\033\n\027"
    "ITEM_SUBTYPE_PLANT_SEED\020\003\022\032\n\026ITEM_SUBTYP"
    "E_BLOCKMINE\020\004\022\025\n\021ITEM_SUBTYPE_FOOD\020\005\022\033\n\027"
    "ITEM_SUBTYPE_MEDICAMENT\020\006\022\026\n\022ITEM_SUBTYP"
    "E_PLANT\020\007\022\031\n\025ITEM_SUBTYPE_SURVIVAL\020\010\022\026\n\022"
    "ITEM_SUBTYPE_CHEST\020\t\022\026\n\022ITEM_SUBTYPE_GRA"
    "SS\020\n\022\034\n\030ITEM_SUBTYPE_INTERACTIVE\020\013\022\030\n\024IT"
    "EM_SUBTYPE_EXPLORE\020\014\022\027\n\023ITEM_SUBTYPE_SPO"
    "ILS\020\r\022\031\n\025ITEM_SUBTYPE_CURRENCY\020\016\022\037\n\033ITEM"
    "_SUBTYPE_ENDLESS_POTION\020\017\022\036\n\032ITEM_SUBTYP"
    "E_ENDLESS_PIECE\020\020\022\032\n\026ITEM_SUBTYPE_TURNTA"
    "BLE\020\021\022\031\n\025ITEM_SUBTYPE_PET_FOOD\020\022\022\030\n\024ITEM"
    "_SUBTYPE_PET_EGG\020\023\022\034\n\030ITEM_SUBTYPE_PET_C"
    "APTURE\020\024\022\037\n\033ITEM_SUBTYPE_PET_SKILL_BOOK\020"
    "\025\022\031\n\025ITEM_SUBTYPE_MOB_SOUL\020\026\022\031\n\025ITEM_SUB"
    "TYPE_EXP_BALL\020\027\022\027\n\023ITEM_SUBTYPE_ANIMAL\020\030"
    "\022\030\n\024ITEM_SUBTYPE_ANTIQUE\020\031\022\034\n\030ITEM_SUBTY"
    "PE_RENAME_CARD\020\032\022\026\n\022ITEM_SUBTYPE_HONOR\020\033"
    "\022\030\n\024ITEM_SUBTYPE_ESSENCE\020\034\022\024\n\020ITEM_SUBTY"
    "PE_BOX\020\035\022\030\n\024ITEM_SUBTYPE_ADS_MOB\020\036\022\031\n\025IT"
    "EM_SUBTYPE_GIFT_BOX\020\037\022\031\n\025ITEM_SUBTYPE_NP"
    "C_TEMP\020 *\267\002\n\nEQUIP_TYPE\022\016\n\nEQUIP_NULL\020\000\022"
    "\017\n\013EQUIP_ARMOR\020\001\022\026\n\022EQUIP_MELEE_WEQPON\020\024"
    "\022\027\n\023EQUIP_RANGED_WEQPON\020\025\022\026\n\022EQUIP_MAGIC"
    "_WEQPON\020\026\022\031\n\025EQUIP_THROWING_WEQPON\020\027\022\033\n\027"
    "EQUIP_COLLECTION_WEQPON\020\030\022\032\n\026EQUIP_MELEE"
    "_WEQPON_COS\020-\022\033\n\027EQUIP_RANGED_WEQPON_COS"
    "\020.\022\032\n\026EQUIP_MAGIC_WEQPON_COS\020/\022\035\n\031EQUIP_"
    "THROWING_WEQPON_COS\0200\022\023\n\017EQUIP_PET_ARMOR"
    "\0202*\217\004\n\017ARMOR_EQUIP_POS\022\024\n\020ARMOR_EQUIP_NU"
    "LL\020\000\022\024\n\020ARMOR_EQUIP_HEAD\020\001\022\027\n\023ARMOR_EQUI"
    "P_CLOTHES\020\002\022\025\n\021ARMOR_EQUIP_PANTS\020\003\022\024\n\020AR"
    "MOR_EQUIP_BACK\020\004\022\024\n\020ARMOR_EQUIP_SHOE\020\005\022\026"
    "\n\022ARMOR_EQUIP_AMULET\020\006\022\030\n\024ARMOR_EQUIP_CO"
    "S_HEAD\020\007\022\033\n\027ARMOR_EQUIP_COS_CLOTHES\020\010\022\031\n"
    "\025ARMOR_EQUIP_COS_PANTS\020\t\022\030\n\024ARMOR_EQUIP_"
    "COS_BACK\020\n\022\030\n\024ARMOR_EQUIP_COS_SHOE\020\013\022\032\n\026"
    "ARMOR_EQUIP_COS_WEAPON\020\014\022\032\n\026ARMOR_EQUIP_"
    "COS_EFFECT\020\r\022\026\n\022ARMOR_EQUIP_WEAPON\020\016\022\025\n\021"
    "ARMOR_EQUIP_HORSE\020\017\022\032\n\026ARMOR_EQUIP_FOLLO"
    "W_PET\020\020\022\032\n\026ARMOR_EQUIP_PET_COLLAR\020\036\022\033\n\027A"
    "RMOR_EQUIP_PET_CLOTHES\020\037\022\032\n\026ARMOR_EQUIP_"
    "PET_AMULET\020 *\356\024\n\020ROLE_EFFECT_TYPE\022\024\n\020ROL"
    "E_EFFECT_NULL\020\000\022\023\n\017ROLE_EFFECT_HPM\020\001\022\023\n\017"
    "ROLE_EFFECT_MPM\020\002\022\022\n\016ROLE_EFFECT_AD\020\003\022\022\n"
    "\016ROLE_EFFECT_AP\020\004\022\023\n\017ROLE_EFFECT_ARM\020\005\022\024"
    "\n\020ROLE_EFFECT_MARM\020\006\022\022\n\016ROLE_EFFECT_AR\020\007"
    "\022\027\n\023ROLE_EFFECT_MR_FIRE\020\010\022\030\n\024ROLE_EFFECT"
    "_MR_FORST\020\t\022\032\n\026ROLE_EFFECT_MR_THUNDER\020\n\022"
    "\030\n\024ROLE_EFFECT_MR_EARTH\020\013\022\031\n\025ROLE_EFFECT"
    "_MR_POSION\020\014\022\030\n\024ROLE_EFFECT_MR_LIGHT\020\r\022\027"
    "\n\023ROLE_EFFECT_MR_DARK\020\016\022\023\n\017ROLE_EFFECT_A"
    "RP\020\017\022\023\n\017ROLE_EFFECT_MRP\020\020\022\023\n\017ROLE_EFFECT"
    "_CRI\020\021\022\024\n\020ROLE_EFFECT_MCRI\020\022\022\024\n\020ROLE_EFF"
    "ECT_CRID\020\023\022\025\n\021ROLE_EFFECT_MCRID\020\024\022\023\n\017ROL"
    "E_EFFECT_RES\020\025\022\024\n\020ROLE_EFFECT_MRES\020\026\022\026\n\022"
    "ROLE_EFFECT_CC_HIT\020\027\022\026\n\022ROLE_EFFECT_CC_R"
    "ES\020\030\022\026\n\022ROLE_EFFECT_ATK_SP\020\031\022\025\n\021ROLE_EFF"
    "ECT_MV_SP\020\032\022\022\n\016ROLE_EFFECT_HB\020\033\022\023\n\017ROLE_"
    "EFFECT_HPR\020\034\022\024\n\020ROLE_EFFECT_HPRS\020\035\022\023\n\017RO"
    "LE_EFFECT_MPR\020\036\022\024\n\020ROLE_EFFECT_MPRS\020\037\022\032\n"
    "\026ROLE_EFFECT_GATHER_ATK\020 \022\024\n\020ROLE_EFFECT"
    "_JUMP\020!\022\024\n\020ROLE_EFFECT_SWIM\020\"\022\031\n\025ROLE_EF"
    "FECT_ATK_RANGE\020#\022\031\n\025ROLE_EFFECT_GATHER_S"
    "P\020$\022\025\n\021ROLE_EFFECT_CHASE\020%\022\031\n\025ROLE_EFFEC"
    "T_BOSS_HURT\020&\022\035\n\031ROLE_EFFECT_BOSS_DMGRED"
    "UC\020\'\022\037\n\033ROLE_EFFECT_JUMP_INIT_SPEED\020(\022 \n"
    "\034ROLE_EFFECT_TOTAL_DAMAGE_INC\020)\022!\n\035ROLE_"
    "EFFECT_DEBUFF_DAMAGE_INC\020*\022\037\n\033ROLE_EFFEC"
    "T_ATTR_STATIC_MAX\020+\022\030\n\024ROLE_EFFECT_HPM_R"
    "ATE\020e\022\030\n\024ROLE_EFFECT_MPM_RATE\020f\022\027\n\023ROLE_"
    "EFFECT_AD_RATE\020g\022\027\n\023ROLE_EFFECT_AP_RATE\020"
    "h\022\030\n\024ROLE_EFFECT_ARM_RATE\020i\022\031\n\025ROLE_EFFE"
    "CT_MARM_RATE\020j\022\027\n\023ROLE_EFFECT_AR_RATE\020k\022"
    "\034\n\030ROLE_EFFECT_MR_FIRE_RATE\020l\022\035\n\031ROLE_EF"
    "FECT_MR_FORST_RATE\020m\022\037\n\033ROLE_EFFECT_MR_T"
    "HUNDER_RATE\020n\022\035\n\031ROLE_EFFECT_MR_EARTH_RA"
    "TE\020o\022\036\n\032ROLE_EFFECT_MR_POSION_RATE\020p\022\035\n\031"
    "ROLE_EFFECT_MR_LIGHT_RATE\020q\022\034\n\030ROLE_EFFE"
    "CT_MR_DARK_RATE\020r\022\030\n\024ROLE_EFFECT_ARP_RAT"
    "E\020s\022\030\n\024ROLE_EFFECT_MRP_RATE\020t\022\030\n\024ROLE_EF"
    "FECT_CRI_RATE\020u\022\031\n\025ROLE_EFFECT_MCRI_RATE"
    "\020v\022\031\n\025ROLE_EFFECT_CRID_RATE\020w\022\032\n\026ROLE_EF"
    "FECT_MCRID_RATE\020x\022\030\n\024ROLE_EFFECT_RES_RAT"
    "E\020y\022\031\n\025ROLE_EFFECT_MRES_RATE\020z\022\033\n\027ROLE_E"
    "FFECT_CC_HIT_RATE\020{\022\033\n\027ROLE_EFFECT_CC_RE"
    "S_RATE\020|\022\033\n\027ROLE_EFFECT_ATK_SP_RATE\020}\022\032\n"
    "\026ROLE_EFFECT_MV_SP_RATE\020~\022\027\n\023ROLE_EFFECT"
    "_HB_RATE\020\177\022\031\n\024ROLE_EFFECT_HPR_RATE\020\200\001\022\032\n"
    "\025ROLE_EFFECT_HPRS_RATE\020\201\001\022\031\n\024ROLE_EFFECT"
    "_MPR_RATE\020\202\001\022\032\n\025ROLE_EFFECT_MPRS_RATE\020\203\001"
    "\022 \n\033ROLE_EFFECT_GATHER_ATK_RATE\020\204\001\022\032\n\025RO"
    "LE_EFFECT_JUMP_RATE\020\205\001\022\032\n\025ROLE_EFFECT_SW"
    "IM_RATE\020\206\001\022\037\n\032ROLE_EFFECT_ATK_RANGE_RATE"
    "\020\207\001\022\037\n\032ROLE_EFFECT_GATHER_SP_RATE\020\210\001\022\033\n\026"
    "ROLE_EFFECT_CHASE_RATE\020\211\001\022\037\n\032ROLE_EFFECT"
    "_BOSS_HURT_RATE\020\212\001\022#\n\036ROLE_EFFECT_BOSS_D"
    "MGREDUC_RATE\020\213\001\022%\n ROLE_EFFECT_JUMP_INIT"
    "_SPEED_RATE\020\214\001\022&\n!ROLE_EFFECT_TOTAL_DAMA"
    "GE_INC_RATE\020\215\001\022\'\n\"ROLE_EFFECT_DEBUFF_DAM"
    "AGE_INC_RATE\020\216\001\022\036\n\031ROLE_EFFECT_ATTR_RATE"
    "_MAX\020\217\001\022\027\n\022ROLE_EFFECT_MR_ALL\020\311\001\022\034\n\027ROLE"
    "_EFFECT_MR_ALL_RATE\020\312\001\022\031\n\024ROLE_EFFECT_AT"
    "TR_MAX\020\313\001\022\035\n\030ROLE_EFFECT_SKILL_STATUS\020\255\002"
    "\022\033\n\026ROLE_EFFECT_CAST_SKILL\020\221\003\022\032\n\025ROLE_EF"
    "FECT_TRANSPORT\020\222\003\022\031\n\024ROLE_EFFECT_PROSPEC"
    "T\020\223\003\022\036\n\031ROLE_EFFECT_DETECTING_ORE\020\224\003\022\"\n\035"
    "ROLE_EFFECT_DETECTING_DUNGEON\020\225\003\022\035\n\030ROLE"
    "_EFFECT_FALLING_SLOW\020\227\003\022\024\n\017ROLE_EFFECT_M"
    "AX\020\230\003*\236\005\n\014SKILL_STATUS\022\025\n\021SKILL_STATUS_N"
    "ONE\020\000\022\032\n\026SKILL_STATUS_CANT_MOVE\020\001\022\034\n\030SKI"
    "LL_STATUS_CANT_ATTACK\020\002\022\031\n\025SKILL_STATUS_"
    "CANT_DIG\020\004\022\033\n\027SKILL_STATUS_CANT_BUILD\020\010\022"
    "\037\n\033SKILL_STATUS_CANT_CASTSKILL\020\020\022#\n\037SKIL"
    "L_STATUS_DONT_PLAY_HIT_AMIN\020 \022\035\n\031SKILL_S"
    "TATUS_CANT_USEITEM\020@\022\030\n\023SKILL_STATUS_FRE"
    "EZE\020\200\001\022\034\n\027SKILL_STATUS_FOLLOWMOVE\020\200\002\022\033\n\026"
    "SKILL_STATUS_CONFUSION\020\200\004\022\033\n\026SKILL_STATU"
    "S_INVISIBLE\020\200\010\022 \n\033SKILL_STATUS_CANT_BE_A"
    "TTACK\020\200\020\022\036\n\031SKILL_STATUS_PETRIFACTION\020\200 "
    "\022\027\n\022SKILL_STATUS_TAUNT\020\200@\022\032\n\024SKILL_STATU"
    "S_FRESNEL\020\200\200\001\022\033\n\025SKILL_STATUS_CANT_FLY\020\200"
    "\200\002\022\037\n\031SKILL_STATUS_CHANGE_GROUP\020\200\200\004\022\030\n\022S"
    "KILL_STATUS_BLIND\020\200\200\010\022\037\n\031SKILL_STATUS_MO"
    "DEL_CHANGE\020\200\200\020\022$\n\036SKILL_STATUS_CANT_BE_A"
    "TTACK_AI\020\200\200 \022\030\n\022SKILL_STATUS_DREAD\020\200\200@*\220"
    "\001\n\024SURVIVAL_GAME_RESULT\022\035\n\031SURVIVAL_GAME"
    "_RESULT_NONE\020\000\022\034\n\030SURVIVAL_GAME_RESULT_W"
    "in\020\001\022\035\n\031SURVIVAL_GAME_RESULT_Lose\020\002\022\034\n\030S"
    "URVIVAL_GAME_RESULT_END\020\003*\205\002\n\020PROTECTOR_"
    "STATUS\022\036\n\021BADGE_STATUS_LOCK\020\377\377\377\377\377\377\377\377\377\001\022\025"
    "\n\021BADGE_STATUS_NONE\020\000\022\035\n\031BADGE_STATUS_NO"
    "T_REQUIRED\020\001\022\032\n\026BADGE_STATUS_WAIT_JOIN\020\002"
    "\022 \n\034BADGE_STATUS_ENABLE_FUNCTION\020\003\022\026\n\022BA"
    "DGE_STATUS_DEATH\020\004\022\027\n\023BADGE_STATUS_PATRO"
    "L\020\005\022\027\n\023BADGE_STATUS_FOLLOW\020\006\022\023\n\017BADGE_ST"
    "ATUS_SP\020\007*\273\002\n\034PROTECTOR_LESS_THAN_REQUIR"
    "ED\022%\n!PROTECTOR_LESS_THAN_REQUIRED_NONE\020"
    "\000\022&\n\"PROTECTOR_LESS_THAN_REQUIRED_SPACE\020"
    "\001\022%\n!PROTECTOR_LESS_THAN_REQUIRED_WALL\020\002"
    "\022*\n&PROTECTOR_LESS_THAN_REQUIRED_FURNITU"
    "RE\020\003\022(\n$PROTECTOR_LESS_THAN_REQUIRED_COM"
    "FORE\020\004\022\'\n#PROTECTOR_LESS_THAN_REQUIRED_H"
    "EIGHT\020\005\022&\n\"PROTECTOR_LESS_THAN_REQUIRED_"
    "LIGHT\020\006*\220\001\n\023PROTECTOR_WAIT_TYPE\022\034\n\030PROTE"
    "CTOR_WAIT_TYPE_NONE\020\000\022\034\n\030PROTECTOR_WAIT_"
    "TYPE_JOIN\020\001\022\035\n\031PROTECTOR_WAIT_TYPE_LEAVE"
    "\020\002\022\036\n\032PROTECTOR_WAIT_TYPE_REBORN\020\003*\250\001\n\017M"
    "EDICAMENT_TYPE\022\021\n\rMEDICAMENT_HP\020\000\022\025\n\021MED"
    "ICAMENT_HP_PER\020\001\022\021\n\rMEDICAMENT_MP\020\002\022\025\n\021M"
    "EDICAMENT_MP_PER\020\003\022\023\n\017MEDICAMENT_HPMP\020\004\022"
    "\027\n\023MEDICAMENT_HPMP_PER\020\005\022\023\n\017MEDICAMENT_B"
    "UFF\020\006*\205\001\n\016ACHIEVE_STATUS\022\036\n\032ACHIEVE_STAT"
    "US_IN_PROGRESS\020\000\022\035\n\031ACHIEVE_STATUS_ACCOM"
    "PLISH\020\001\022\033\n\027ACHIEVE_STATUS_RECEIVED\020\002\022\027\n\023"
    "ACHIEVE_STATUS_LOCK\020\003*]\n\013MAIL_STATUS\022\026\n\022"
    "MAIL_STATUS_UNREAD\020\000\022\035\n\031MAIL_STATUS_HAS_"
    "BEEN_READ\020\001\022\027\n\023MAIL_STATUS_CLAIMED\020\002*\324\001\n"
    "\rQUALITY_GRADE\022\026\n\022QUALITY_GRADE_NONE\020\000\022\027"
    "\n\023QUALITY_GRADE_WHITE\020\001\022\027\n\023QUALITY_GRADE"
    "_GREEN\020\002\022\026\n\022QUALITY_GRADE_BLUE\020\003\022\030\n\024QUAL"
    "ITY_GRADE_PURPLE\020\004\022\030\n\024QUALITY_GRADE_ORAN"
    "GE\020\005\022\025\n\021QUALITY_GRADE_RED\020\006\022\026\n\022QUALITY_G"
    "RADE_GRAY\020c*Y\n\034QUALITY_GRADE_FOR_DB_SETT"
    "ING\0229\n5QUALITY_GRADE_FOR_DB_SETTING_ROOM"
    "_FURNITURE_ARRAYSIZE\020\007*\255\002\n\022ITEM_CURRENCY"
    "_TYPE\022\033\n\027ITEM_CURRENCY_TYPE_ITEM\020\000\022\035\n\031IT"
    "EM_CURRENCY_TYPE_SILVER\020\001\022\033\n\027ITEM_CURREN"
    "CY_TYPE_GOLD\020\002\022\036\n\032ITEM_CURRENCY_TYPE_DIA"
    "MOND\020\003\022\036\n\032ITEM_CURRENCY_TYPE_ENDLESS\020\004\022 "
    "\n\034ITEM_CURRENCY_TYPE_TURNTABLE\020\005\022\033\n\027ITEM"
    "_CURRENCY_TYPE_SPIN\020\006\022 \n\034ITEM_CURRENCY_T"
    "YPE_ARES_COIN\020\007\022\035\n\031ITEM_CURRENCY_TYPE_DO"
    "LLAR\020b*\236\001\n\014MSG_MOVE_DIR\022\017\n\013MSG_DIR_NOE\020\000"
    "\022\020\n\014MSG_DIR_LEFT\020\001\022\021\n\rMSG_DIR_RIGHT\020\002\022\024\n"
    "\020MSG_DIR_RIGHT_UP\020\003\022\023\n\017MSG_DIR_LEFT_UP\020\004"
    "\022\026\n\022MSG_DIR_RIGHT_DOWN\020\005\022\025\n\021MSG_DIR_LEFT"
    "_DOWN\020\006*\255\001\n\rMSG_MOVE_STAT\022\030\n\024MSG_MOVE_ST"
    "ATE_STAND\020\000\022\027\n\023MSG_MOVE_STATE_WALK\020\001\022\027\n\023"
    "MSG_MOVE_STATE_JUMP\020\002\022\027\n\023MSG_MOVE_STATE_"
    "FALL\020\003\022\033\n\027MSG_MOVE_STATE_CLIME_UP\020\004\022\032\n\026M"
    "SG_MOVE_STATE_GO_DOWN\020\005*\240\001\n\020E_AntiqueQua"
    "lity\022\032\n\026E_AntiqueQuality_Entry\020\001\022\034\n\030E_An"
    "tiqueQuality_General\020\002\022\033\n\027E_AntiqueQuali"
    "ty_Expert\020\003\022\033\n\027E_AntiqueQuality_Master\020\004"
    "\022\030\n\024E_AntiqueQuality_God\020\005*\270\001\n\022E_Antique"
    "Integrity\022\035\n\031E_AntiqueIntegrity_Broken\020\001"
    "\022!\n\035E_AntiqueIntegrity_Incomplete\020\002\022\037\n\033E"
    "_AntiqueIntegrity_Complete\020\003\022\037\n\033E_Antiqu"
    "eIntegrity_Flawless\020\004\022\036\n\032E_AntiqueIntegr"
    "ity_Perfect\020\005*\235\007\n\024EN_FUNCTION_LOCK_BIT\022\035"
    "\n\031EN_FUNCTION_LOCK_BIT_NONE\020\000\022\037\n\033EN_FUNC"
    "TION_LOCK_BIT_NOTICE\020\001\022-\n)EN_FUNCTION_LO"
    "CK_BIT_PRIVATE_DUNGEON_BOSS\020\002\022)\n%EN_FUNC"
    "TION_LOCK_BIT_STRONG_HOLD_BOSS\020\004\022&\n\"EN_F"
    "UNCTION_LOCK_BIT_FUNCTION_MALL\020\010\022+\n\'EN_F"
    "UNCTION_LOCK_BIT_FUNCTION_FINANCIAL\020\020\022&\n"
    "\"EN_FUNCTION_LOCK_BIT_FUNCTION_SLOT\020 \022\'\n"
    "#EN_FUNCTION_LOCK_BIT_FUNCTION_CHEST\020@\022."
    "\n)EN_FUNCTION_LOCK_BIT_FUNCTION_ANIMAL_F"
    "EED\020\200\001\0224\n/EN_FUNCTION_LOCK_BIT_FUNCTION_"
    "CRYSTAL_TURNTABLE\020\200\002\0221\n,EN_FUNCTION_LOCK"
    "_BIT_FUNCTION_GOLD_TURNTABLE\020\200\004\022,\n\'EN_FU"
    "NCTION_LOCK_BIT_FUNCTION_NPC_ORDER\020\200\010\0224\n"
    "/EN_FUNCTION_LOCK_BIT_FUNCTION_NPC_BATTL"
    "E_REWARD\020\200\020\022+\n&EN_FUNCTION_LOCK_BIT_FUNC"
    "TION_NPC_MINE\020\200 \022.\n)EN_FUNCTION_LOCK_BIT"
    "_FUNCTION_NPC_DUNGEON\020\200@\022,\n&EN_FUNCTION_"
    "LOCK_BIT_FUNCTION_NPC_BUYS\020\200\200\001\022,\n&EN_FUN"
    "CTION_LOCK_BIT_FUNCTION_NPC_SELL\020\200\200\002\0222\n,"
    "EN_FUNCTION_LOCK_BIT_FUNCTION_JOURNAL_RE"
    "WRAD\020\200\200\004\022)\n#EN_FUNCTION_LOCK_BIT_FUNCTIO"
    "N_SCORE\020\200\200\010\0220\n*EN_FUNCTION_LOCK_BIT_FUNC"
    "TION_SUBSCRIPTION\020\200\200\020*\326\024\n\024EN_PLAYER_EVEN"
    "T_TYPE\022\035\n\031EN_PLAYER_EVENT_TYPE_NONE\020\000\022\'\n"
    "#EN_PLAYER_EVENT_TYPE_shootcup_share\020\001\022$"
    "\n EN_PLAYER_EVENT_TYPE_login_Daily\020\002\022 \n\034"
    "EN_PLAYER_EVENT_TYPE_sign_in\020\003\022\"\n\036EN_PLA"
    "YER_EVENT_TYPE_dig_block\020\004\022!\n\035EN_PLAYER_"
    "EVENT_TYPE_dig_mine\020\005\022\"\n\036EN_PLAYER_EVENT"
    "_TYPE_dig_plant\020\006\022!\n\035EN_PLAYER_EVENT_TYP"
    "E_kill_mob\020\007\022\"\n\036EN_PLAYER_EVENT_TYPE_kil"
    "l_boss\020\010\022 \n\034EN_PLAYER_EVENT_TYPE_compose"
    "\020\t\022$\n EN_PLAYER_EVENT_TYPE_TaskNPcrepo\020\n"
    "\022!\n\035EN_PLAYER_EVENT_TYPE_eat_food\020\013\022#\n\037E"
    "N_PLAYER_EVENT_TYPE_home_visit\020\014\022$\n EN_P"
    "LAYER_EVENT_TYPE_world_share\020\r\022\"\n\036EN_PLA"
    "YER_EVENT_TYPE_plant_set\020\016\022$\n EN_PLAYER_"
    "EVENT_TYPE_animal_feed\020\017\022#\n\037EN_PLAYER_EV"
    "ENT_TYPE_animal_get\020\020\022\035\n\031EN_PLAYER_EVENT"
    "_TYPE_spin\020\021\022%\n!EN_PLAYER_EVENT_TYPE_Npc"
    "PetBounty\020\022\022\'\n#EN_PLAYER_EVENT_TYPE_equi"
    "pment_wash\020\023\022#\n\037EN_PLAYER_EVENT_TYPE_vie"
    "w_video\020\024\022%\n!EN_PLAYER_EVENT_TYPE_consum"
    "e_cash\020\025\022!\n\035EN_PLAYER_EVENT_TYPE_Towerpv"
    "p\020\026\022!\n\035EN_PLAYER_EVENT_TYPE_PvpSquad\020\027\022#"
    "\n\037EN_PLAYER_EVENT_TYPE_open_chest\020\030\022%\n!E"
    "N_PLAYER_EVENT_TYPE_transfer_map\020\031\022%\n!EN"
    "_PLAYER_EVENT_TYPE_repair_equip\020\032\022\'\n#EN_"
    "PLAYER_EVENT_TYPE_mysterious_man\020\033\022&\n\"EN"
    "_PLAYER_EVENT_TYPE_achieve_level\020\034\022(\n$EN"
    "_PLAYER_EVENT_TYPE_equip_suit_rare\020\035\022&\n\""
    "EN_PLAYER_EVENT_TYPE_equip_upgrade\020\036\022\'\n#"
    "EN_PLAYER_EVENT_TYPE_npc_equip_suit\020\037\022\"\n"
    "\036EN_PLAYER_EVENT_TYPE_npc_power\020 \022(\n$EN_"
    "PLAYER_EVENT_TYPE_npc_use_essence\020!\022$\n E"
    "N_PLAYER_EVENT_TYPE_pet_quality\020\"\022%\n!EN_"
    "PLAYER_EVENT_TYPE_pet_level_up\020#\022(\n$EN_P"
    "LAYER_EVENT_TYPE_pet_change_data\020$\022(\n$EN"
    "_PLAYER_EVENT_TYPE_pet_use_essence\020%\022\"\n\036"
    "EN_PLAYER_EVENT_TYPE_put_build\020&\022\'\n#EN_P"
    "LAYER_EVENT_TYPE_pvp_squad_rank\020\'\022&\n\"EN_"
    "PLAYER_EVENT_TYPE_towerpvp_rank\020(\022\"\n\036EN_"
    "PLAYER_EVENT_TYPE_sell_item\020)\022(\n$EN_PLAY"
    "ER_EVENT_TYPE_tower_challenge\020*\022.\n*EN_PL"
    "AYER_EVENT_TYPE_tower_challenge_score\020+\022"
    "%\n!EN_PLAYER_EVENT_TYPE_repair_build\020,\022\""
    "\n\036EN_PLAYER_EVENT_TYPE_pet_power\020-\022\'\n#EN"
    "_PLAYER_EVENT_TYPE_pet_equip_suit\020.\022!\n\035E"
    "N_PLAYER_EVENT_TYPE_npc_gift\020/\022#\n\037EN_PLA"
    "YER_EVENT_TYPE_put_animal\0200\022/\n+EN_PLAYER"
    "_EVENT_TYPE_sell_item_get_currency\0201\022\'\n#"
    "EN_PLAYER_EVENT_TYPE_identify_equip\0202\022+\n"
    "\'EN_PLAYER_EVENT_TYPE_player_use_essence"
    "\0203\022(\n$EN_PLAYER_EVENT_TYPE_compose_patte"
    "rn\0204\022#\n\037EN_PLAYER_EVENT_TYPE_arrive_map\020"
    "7\022&\n\"EN_PLAYER_EVENT_TYPE_get_drop_item\020"
    "8\0223\n/EN_PLAYER_EVENT_TYPE_interactive_bu"
    "ild_level_up\0209\022!\n\035EN_PLAYER_EVENT_TYPE_u"
    "se_item\020:\022&\n\"EN_PLAYER_EVENT_TYPE_get_pr"
    "otector\020;\022(\n$EN_PLAYER_EVENT_TYPE_pet_le"
    "arn_skill\020<\022!\n\035EN_PLAYER_EVENT_TYPE_own_"
    "room\020=\022&\n\"EN_PLAYER_EVENT_TYPE_put_prote"
    "ctor\020>\022%\n!EN_PLAYER_EVENT_TYPE_room_comf"
    "ort\020\?\022!\n\035EN_PLAYER_EVENT_TYPE_get_rent\020@"
    "\022-\n)EN_PLAYER_EVENT_TYPE_tower_build_lev"
    "el_up\020A\022.\n*EN_PLAYER_EVENT_TYPE_crystal_"
    "energy_supply\020C\022.\n*EN_PLAYER_EVENT_TYPE_"
    "receive_npc_automatic\020D\022-\n)EN_PLAYER_EVE"
    "NT_TYPE_achievement_complete\020E*\252\001\n\016GAME_"
    "NEWS_TYPE\022\027\n\023GAME_NEWS_TURNTABLE\020\001\022\035\n\031GA"
    "ME_NEWS_BUY_DEPOSIT_POT\020\002\022\035\n\031GAME_NEWS_B"
    "UY_FUND_TICKET\020\003\022!\n\035GAME_NEWS_SS_PET_AND"
    "_5_SKILLS\020\004\022\036\n\032GAME_NEWS_PET_OWN_5_SKILL"
    "S\020\005", 13803);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "MsgGameDef.proto", &protobuf_RegisterTypes);
  MsgPoint::default_instance_ = new MsgPoint();
  MsgSize::default_instance_ = new MsgSize();
  MsgArea::default_instance_ = new MsgArea();
  MsgCircle::default_instance_ = new MsgCircle();
  MsgGateTarget::default_instance_ = new MsgGateTarget();
  KeyVal::default_instance_ = new KeyVal();
  KeyValI64::default_instance_ = new KeyValI64();
  AttrEffect::default_instance_ = new AttrEffect();
  UnderAttack::default_instance_ = new UnderAttack();
  ItemReward::default_instance_ = new ItemReward();
  MsgRepeatedUUID::default_instance_ = new MsgRepeatedUUID();
  MsgPoint::default_instance_->InitAsDefaultInstance();
  MsgSize::default_instance_->InitAsDefaultInstance();
  MsgArea::default_instance_->InitAsDefaultInstance();
  MsgCircle::default_instance_->InitAsDefaultInstance();
  MsgGateTarget::default_instance_->InitAsDefaultInstance();
  KeyVal::default_instance_->InitAsDefaultInstance();
  KeyValI64::default_instance_->InitAsDefaultInstance();
  AttrEffect::default_instance_->InitAsDefaultInstance();
  UnderAttack::default_instance_->InitAsDefaultInstance();
  ItemReward::default_instance_->InitAsDefaultInstance();
  MsgRepeatedUUID::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_MsgGameDef_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_MsgGameDef_2eproto {
  StaticDescriptorInitializer_MsgGameDef_2eproto() {
    protobuf_AddDesc_MsgGameDef_2eproto();
  }
} static_descriptor_initializer_MsgGameDef_2eproto_;
const ::google::protobuf::EnumDescriptor* E_ErrorCode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return E_ErrorCode_descriptor_;
}
bool E_ErrorCode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 50001:
    case 50002:
    case 50003:
    case 50004:
    case 50010:
    case 50011:
    case 50013:
    case 50014:
    case 50015:
    case 50016:
    case 50017:
    case 50018:
    case 50051:
    case 50052:
    case 50053:
    case 50054:
    case 50055:
    case 50056:
    case 60001:
    case 60002:
    case 60101:
    case 60102:
    case 60103:
    case 60201:
    case 60202:
    case 71001:
    case 72001:
    case 72002:
    case 72003:
    case 81001:
    case 81002:
    case 81011:
    case 81012:
    case 81013:
    case 81014:
    case 81021:
    case 81022:
    case 81023:
    case 101001:
    case 101002:
    case 101003:
    case 101004:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ITEM_SUBTYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ITEM_SUBTYPE_descriptor_;
}
bool ITEM_SUBTYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EQUIP_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EQUIP_TYPE_descriptor_;
}
bool EQUIP_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 45:
    case 46:
    case 47:
    case 48:
    case 50:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ARMOR_EQUIP_POS_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ARMOR_EQUIP_POS_descriptor_;
}
bool ARMOR_EQUIP_POS_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 30:
    case 31:
    case 32:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ROLE_EFFECT_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ROLE_EFFECT_TYPE_descriptor_;
}
bool ROLE_EFFECT_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 201:
    case 202:
    case 203:
    case 301:
    case 401:
    case 402:
    case 403:
    case 404:
    case 405:
    case 407:
    case 408:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SKILL_STATUS_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SKILL_STATUS_descriptor_;
}
bool SKILL_STATUS_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SURVIVAL_GAME_RESULT_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SURVIVAL_GAME_RESULT_descriptor_;
}
bool SURVIVAL_GAME_RESULT_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PROTECTOR_STATUS_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PROTECTOR_STATUS_descriptor_;
}
bool PROTECTOR_STATUS_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PROTECTOR_LESS_THAN_REQUIRED_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PROTECTOR_LESS_THAN_REQUIRED_descriptor_;
}
bool PROTECTOR_LESS_THAN_REQUIRED_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PROTECTOR_WAIT_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PROTECTOR_WAIT_TYPE_descriptor_;
}
bool PROTECTOR_WAIT_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* MEDICAMENT_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MEDICAMENT_TYPE_descriptor_;
}
bool MEDICAMENT_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ACHIEVE_STATUS_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACHIEVE_STATUS_descriptor_;
}
bool ACHIEVE_STATUS_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* MAIL_STATUS_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MAIL_STATUS_descriptor_;
}
bool MAIL_STATUS_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* QUALITY_GRADE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return QUALITY_GRADE_descriptor_;
}
bool QUALITY_GRADE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 99:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* QUALITY_GRADE_FOR_DB_SETTING_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return QUALITY_GRADE_FOR_DB_SETTING_descriptor_;
}
bool QUALITY_GRADE_FOR_DB_SETTING_IsValid(int value) {
  switch(value) {
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ITEM_CURRENCY_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ITEM_CURRENCY_TYPE_descriptor_;
}
bool ITEM_CURRENCY_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 98:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* MSG_MOVE_DIR_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MSG_MOVE_DIR_descriptor_;
}
bool MSG_MOVE_DIR_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* MSG_MOVE_STAT_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MSG_MOVE_STAT_descriptor_;
}
bool MSG_MOVE_STAT_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* E_AntiqueQuality_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return E_AntiqueQuality_descriptor_;
}
bool E_AntiqueQuality_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* E_AntiqueIntegrity_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return E_AntiqueIntegrity_descriptor_;
}
bool E_AntiqueIntegrity_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EN_FUNCTION_LOCK_BIT_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EN_FUNCTION_LOCK_BIT_descriptor_;
}
bool EN_FUNCTION_LOCK_BIT_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EN_PLAYER_EVENT_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EN_PLAYER_EVENT_TYPE_descriptor_;
}
bool EN_PLAYER_EVENT_TYPE_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 67:
    case 68:
    case 69:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* GAME_NEWS_TYPE_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GAME_NEWS_TYPE_descriptor_;
}
bool GAME_NEWS_TYPE_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int MsgPoint::kXFieldNumber;
const int MsgPoint::kYFieldNumber;
#endif  // !_MSC_VER

MsgPoint::MsgPoint()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.MsgPoint)
}

void MsgPoint::InitAsDefaultInstance() {
}

MsgPoint::MsgPoint(const MsgPoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.MsgPoint)
}

void MsgPoint::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgPoint::~MsgPoint() {
  // @@protoc_insertion_point(destructor:MsgPB.MsgPoint)
  SharedDtor();
}

void MsgPoint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgPoint_descriptor_;
}

const MsgPoint& MsgPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

MsgPoint* MsgPoint::default_instance_ = NULL;

MsgPoint* MsgPoint::New() const {
  return new MsgPoint;
}

void MsgPoint::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgPoint*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.MsgPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // optional int32 y = 2;
      case 2: {
        if (tag == 16) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.MsgPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.MsgPoint)
  return false;
#undef DO_
}

void MsgPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.MsgPoint)
  // optional int32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // optional int32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.MsgPoint)
}

::google::protobuf::uint8* MsgPoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.MsgPoint)
  // optional int32 x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // optional int32 y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.MsgPoint)
  return target;
}

int MsgPoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgPoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgPoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgPoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgPoint::MergeFrom(const MsgPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgPoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgPoint::CopyFrom(const MsgPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgPoint::IsInitialized() const {

  return true;
}

void MsgPoint::Swap(MsgPoint* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgPoint_descriptor_;
  metadata.reflection = MsgPoint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgSize::kWidthFieldNumber;
const int MsgSize::kHeightFieldNumber;
#endif  // !_MSC_VER

MsgSize::MsgSize()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.MsgSize)
}

void MsgSize::InitAsDefaultInstance() {
}

MsgSize::MsgSize(const MsgSize& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.MsgSize)
}

void MsgSize::SharedCtor() {
  _cached_size_ = 0;
  width_ = 0;
  height_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgSize::~MsgSize() {
  // @@protoc_insertion_point(destructor:MsgPB.MsgSize)
  SharedDtor();
}

void MsgSize::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgSize::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgSize_descriptor_;
}

const MsgSize& MsgSize::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

MsgSize* MsgSize::default_instance_ = NULL;

MsgSize* MsgSize::New() const {
  return new MsgSize;
}

void MsgSize::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgSize*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(width_, height_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.MsgSize)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 width = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_height;
        break;
      }

      // optional int32 height = 2;
      case 2: {
        if (tag == 16) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.MsgSize)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.MsgSize)
  return false;
#undef DO_
}

void MsgSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.MsgSize)
  // optional int32 width = 1;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->width(), output);
  }

  // optional int32 height = 2;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->height(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.MsgSize)
}

::google::protobuf::uint8* MsgSize::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.MsgSize)
  // optional int32 width = 1;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->width(), target);
  }

  // optional int32 height = 2;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->height(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.MsgSize)
  return target;
}

int MsgSize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 width = 1;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }

    // optional int32 height = 2;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgSize::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgSize* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgSize*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgSize::MergeFrom(const MsgSize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgSize::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgSize::CopyFrom(const MsgSize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgSize::IsInitialized() const {

  return true;
}

void MsgSize::Swap(MsgSize* other) {
  if (other != this) {
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgSize::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgSize_descriptor_;
  metadata.reflection = MsgSize_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgArea::kLeftFieldNumber;
const int MsgArea::kTopFieldNumber;
const int MsgArea::kRightFieldNumber;
const int MsgArea::kBottomFieldNumber;
#endif  // !_MSC_VER

MsgArea::MsgArea()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.MsgArea)
}

void MsgArea::InitAsDefaultInstance() {
}

MsgArea::MsgArea(const MsgArea& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.MsgArea)
}

void MsgArea::SharedCtor() {
  _cached_size_ = 0;
  left_ = 0;
  top_ = 0;
  right_ = 0;
  bottom_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgArea::~MsgArea() {
  // @@protoc_insertion_point(destructor:MsgPB.MsgArea)
  SharedDtor();
}

void MsgArea::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgArea::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgArea::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgArea_descriptor_;
}

const MsgArea& MsgArea::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

MsgArea* MsgArea::default_instance_ = NULL;

MsgArea* MsgArea::New() const {
  return new MsgArea;
}

void MsgArea::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgArea*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(left_, bottom_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgArea::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.MsgArea)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 left = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &left_)));
          set_has_left();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_top;
        break;
      }

      // optional int32 top = 2;
      case 2: {
        if (tag == 16) {
         parse_top:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &top_)));
          set_has_top();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_right;
        break;
      }

      // optional int32 right = 3;
      case 3: {
        if (tag == 24) {
         parse_right:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &right_)));
          set_has_right();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_bottom;
        break;
      }

      // optional int32 bottom = 4;
      case 4: {
        if (tag == 32) {
         parse_bottom:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bottom_)));
          set_has_bottom();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.MsgArea)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.MsgArea)
  return false;
#undef DO_
}

void MsgArea::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.MsgArea)
  // optional int32 left = 1;
  if (has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->left(), output);
  }

  // optional int32 top = 2;
  if (has_top()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->top(), output);
  }

  // optional int32 right = 3;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->right(), output);
  }

  // optional int32 bottom = 4;
  if (has_bottom()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->bottom(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.MsgArea)
}

::google::protobuf::uint8* MsgArea::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.MsgArea)
  // optional int32 left = 1;
  if (has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->left(), target);
  }

  // optional int32 top = 2;
  if (has_top()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->top(), target);
  }

  // optional int32 right = 3;
  if (has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->right(), target);
  }

  // optional int32 bottom = 4;
  if (has_bottom()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->bottom(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.MsgArea)
  return target;
}

int MsgArea::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 left = 1;
    if (has_left()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->left());
    }

    // optional int32 top = 2;
    if (has_top()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->top());
    }

    // optional int32 right = 3;
    if (has_right()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->right());
    }

    // optional int32 bottom = 4;
    if (has_bottom()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bottom());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgArea::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgArea* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgArea*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgArea::MergeFrom(const MsgArea& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_left()) {
      set_left(from.left());
    }
    if (from.has_top()) {
      set_top(from.top());
    }
    if (from.has_right()) {
      set_right(from.right());
    }
    if (from.has_bottom()) {
      set_bottom(from.bottom());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgArea::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgArea::CopyFrom(const MsgArea& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgArea::IsInitialized() const {

  return true;
}

void MsgArea::Swap(MsgArea* other) {
  if (other != this) {
    std::swap(left_, other->left_);
    std::swap(top_, other->top_);
    std::swap(right_, other->right_);
    std::swap(bottom_, other->bottom_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgArea::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgArea_descriptor_;
  metadata.reflection = MsgArea_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgCircle::kXFieldNumber;
const int MsgCircle::kYFieldNumber;
const int MsgCircle::kRadiusFieldNumber;
#endif  // !_MSC_VER

MsgCircle::MsgCircle()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.MsgCircle)
}

void MsgCircle::InitAsDefaultInstance() {
}

MsgCircle::MsgCircle(const MsgCircle& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.MsgCircle)
}

void MsgCircle::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgCircle::~MsgCircle() {
  // @@protoc_insertion_point(destructor:MsgPB.MsgCircle)
  SharedDtor();
}

void MsgCircle::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgCircle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgCircle::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgCircle_descriptor_;
}

const MsgCircle& MsgCircle::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

MsgCircle* MsgCircle::default_instance_ = NULL;

MsgCircle* MsgCircle::New() const {
  return new MsgCircle;
}

void MsgCircle::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgCircle*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, radius_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgCircle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.MsgCircle)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // optional int32 y = 2;
      case 2: {
        if (tag == 16) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_radius;
        break;
      }

      // optional int32 radius = 3;
      case 3: {
        if (tag == 24) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.MsgCircle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.MsgCircle)
  return false;
#undef DO_
}

void MsgCircle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.MsgCircle)
  // optional int32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // optional int32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // optional int32 radius = 3;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->radius(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.MsgCircle)
}

::google::protobuf::uint8* MsgCircle::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.MsgCircle)
  // optional int32 x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->x(), target);
  }

  // optional int32 y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->y(), target);
  }

  // optional int32 radius = 3;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->radius(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.MsgCircle)
  return target;
}

int MsgCircle::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

    // optional int32 radius = 3;
    if (has_radius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->radius());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgCircle::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgCircle* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgCircle*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgCircle::MergeFrom(const MsgCircle& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgCircle::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgCircle::CopyFrom(const MsgCircle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgCircle::IsInitialized() const {

  return true;
}

void MsgCircle::Swap(MsgCircle* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(radius_, other->radius_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgCircle::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgCircle_descriptor_;
  metadata.reflection = MsgCircle_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgGateTarget::kIdFieldNumber;
const int MsgGateTarget::kTypeFieldNumber;
const int MsgGateTarget::kMapIdFieldNumber;
const int MsgGateTarget::kGateidFieldNumber;
const int MsgGateTarget::kPosFieldNumber;
#endif  // !_MSC_VER

MsgGateTarget::MsgGateTarget()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.MsgGateTarget)
}

void MsgGateTarget::InitAsDefaultInstance() {
  pos_ = const_cast< ::MsgPB::MsgPoint*>(&::MsgPB::MsgPoint::default_instance());
}

MsgGateTarget::MsgGateTarget(const MsgGateTarget& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.MsgGateTarget)
}

void MsgGateTarget::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  type_ = 0;
  mapid_ = 0;
  gateid_ = 0;
  pos_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgGateTarget::~MsgGateTarget() {
  // @@protoc_insertion_point(destructor:MsgPB.MsgGateTarget)
  SharedDtor();
}

void MsgGateTarget::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
  }
}

void MsgGateTarget::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgGateTarget::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgGateTarget_descriptor_;
}

const MsgGateTarget& MsgGateTarget::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

MsgGateTarget* MsgGateTarget::default_instance_ = NULL;

MsgGateTarget* MsgGateTarget::New() const {
  return new MsgGateTarget;
}

void MsgGateTarget::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgGateTarget*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(id_, gateid_);
    if (has_pos()) {
      if (pos_ != NULL) pos_->::MsgPB::MsgPoint::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgGateTarget::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.MsgGateTarget)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional int32 type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_mapId;
        break;
      }

      // optional int32 mapId = 3;
      case 3: {
        if (tag == 24) {
         parse_mapId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_gateid;
        break;
      }

      // optional int32 gateid = 4;
      case 4: {
        if (tag == 32) {
         parse_gateid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gateid_)));
          set_has_gateid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_pos;
        break;
      }

      // optional .MsgPB.MsgPoint pos = 5;
      case 5: {
        if (tag == 42) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.MsgGateTarget)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.MsgGateTarget)
  return false;
#undef DO_
}

void MsgGateTarget::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.MsgGateTarget)
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // optional int32 mapId = 3;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->mapid(), output);
  }

  // optional int32 gateid = 4;
  if (has_gateid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->gateid(), output);
  }

  // optional .MsgPB.MsgPoint pos = 5;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->pos(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.MsgGateTarget)
}

::google::protobuf::uint8* MsgGateTarget::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.MsgGateTarget)
  // optional int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->type(), target);
  }

  // optional int32 mapId = 3;
  if (has_mapid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->mapid(), target);
  }

  // optional int32 gateid = 4;
  if (has_gateid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->gateid(), target);
  }

  // optional .MsgPB.MsgPoint pos = 5;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->pos(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.MsgGateTarget)
  return target;
}

int MsgGateTarget::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 mapId = 3;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mapid());
    }

    // optional int32 gateid = 4;
    if (has_gateid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gateid());
    }

    // optional .MsgPB.MsgPoint pos = 5;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pos());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgGateTarget::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgGateTarget* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgGateTarget*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgGateTarget::MergeFrom(const MsgGateTarget& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
    if (from.has_gateid()) {
      set_gateid(from.gateid());
    }
    if (from.has_pos()) {
      mutable_pos()->::MsgPB::MsgPoint::MergeFrom(from.pos());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgGateTarget::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgGateTarget::CopyFrom(const MsgGateTarget& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgGateTarget::IsInitialized() const {

  return true;
}

void MsgGateTarget::Swap(MsgGateTarget* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(mapid_, other->mapid_);
    std::swap(gateid_, other->gateid_);
    std::swap(pos_, other->pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgGateTarget::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgGateTarget_descriptor_;
  metadata.reflection = MsgGateTarget_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyVal::kKeyFieldNumber;
const int KeyVal::kValFieldNumber;
#endif  // !_MSC_VER

KeyVal::KeyVal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.KeyVal)
}

void KeyVal::InitAsDefaultInstance() {
}

KeyVal::KeyVal(const KeyVal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.KeyVal)
}

void KeyVal::SharedCtor() {
  _cached_size_ = 0;
  key_ = 0;
  val_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyVal::~KeyVal() {
  // @@protoc_insertion_point(destructor:MsgPB.KeyVal)
  SharedDtor();
}

void KeyVal::SharedDtor() {
  if (this != default_instance_) {
  }
}

void KeyVal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyVal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyVal_descriptor_;
}

const KeyVal& KeyVal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

KeyVal* KeyVal::default_instance_ = NULL;

KeyVal* KeyVal::New() const {
  return new KeyVal;
}

void KeyVal::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<KeyVal*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(key_, val_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyVal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.KeyVal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 key = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &key_)));
          set_has_key();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_val;
        break;
      }

      // optional int32 val = 2;
      case 2: {
        if (tag == 16) {
         parse_val:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &val_)));
          set_has_val();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.KeyVal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.KeyVal)
  return false;
#undef DO_
}

void KeyVal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.KeyVal)
  // optional int32 key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->key(), output);
  }

  // optional int32 val = 2;
  if (has_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->val(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.KeyVal)
}

::google::protobuf::uint8* KeyVal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.KeyVal)
  // optional int32 key = 1;
  if (has_key()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->key(), target);
  }

  // optional int32 val = 2;
  if (has_val()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->val(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.KeyVal)
  return target;
}

int KeyVal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->key());
    }

    // optional int32 val = 2;
    if (has_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->val());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyVal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyVal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyVal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyVal::MergeFrom(const KeyVal& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_val()) {
      set_val(from.val());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyVal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyVal::CopyFrom(const KeyVal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyVal::IsInitialized() const {

  return true;
}

void KeyVal::Swap(KeyVal* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(val_, other->val_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyVal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyVal_descriptor_;
  metadata.reflection = KeyVal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyValI64::kKeyFieldNumber;
const int KeyValI64::kValFieldNumber;
#endif  // !_MSC_VER

KeyValI64::KeyValI64()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.KeyValI64)
}

void KeyValI64::InitAsDefaultInstance() {
}

KeyValI64::KeyValI64(const KeyValI64& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.KeyValI64)
}

void KeyValI64::SharedCtor() {
  _cached_size_ = 0;
  key_ = GOOGLE_LONGLONG(0);
  val_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyValI64::~KeyValI64() {
  // @@protoc_insertion_point(destructor:MsgPB.KeyValI64)
  SharedDtor();
}

void KeyValI64::SharedDtor() {
  if (this != default_instance_) {
  }
}

void KeyValI64::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyValI64::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyValI64_descriptor_;
}

const KeyValI64& KeyValI64::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

KeyValI64* KeyValI64::default_instance_ = NULL;

KeyValI64* KeyValI64::New() const {
  return new KeyValI64;
}

void KeyValI64::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<KeyValI64*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(key_, val_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyValI64::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.KeyValI64)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 key = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &key_)));
          set_has_key();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_val;
        break;
      }

      // optional int32 val = 2;
      case 2: {
        if (tag == 16) {
         parse_val:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &val_)));
          set_has_val();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.KeyValI64)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.KeyValI64)
  return false;
#undef DO_
}

void KeyValI64::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.KeyValI64)
  // optional int64 key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->key(), output);
  }

  // optional int32 val = 2;
  if (has_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->val(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.KeyValI64)
}

::google::protobuf::uint8* KeyValI64::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.KeyValI64)
  // optional int64 key = 1;
  if (has_key()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->key(), target);
  }

  // optional int32 val = 2;
  if (has_val()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->val(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.KeyValI64)
  return target;
}

int KeyValI64::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->key());
    }

    // optional int32 val = 2;
    if (has_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->val());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyValI64::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyValI64* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyValI64*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyValI64::MergeFrom(const KeyValI64& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_val()) {
      set_val(from.val());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyValI64::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyValI64::CopyFrom(const KeyValI64& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyValI64::IsInitialized() const {

  return true;
}

void KeyValI64::Swap(KeyValI64* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(val_, other->val_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyValI64::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyValI64_descriptor_;
  metadata.reflection = KeyValI64_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AttrEffect::kTypeFieldNumber;
const int AttrEffect::kValuesFieldNumber;
#endif  // !_MSC_VER

AttrEffect::AttrEffect()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.AttrEffect)
}

void AttrEffect::InitAsDefaultInstance() {
}

AttrEffect::AttrEffect(const AttrEffect& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.AttrEffect)
}

void AttrEffect::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AttrEffect::~AttrEffect() {
  // @@protoc_insertion_point(destructor:MsgPB.AttrEffect)
  SharedDtor();
}

void AttrEffect::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AttrEffect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AttrEffect::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AttrEffect_descriptor_;
}

const AttrEffect& AttrEffect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

AttrEffect* AttrEffect::default_instance_ = NULL;

AttrEffect* AttrEffect::New() const {
  return new AttrEffect;
}

void AttrEffect::Clear() {
  type_ = 0;
  values_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AttrEffect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.AttrEffect)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MsgPB.ROLE_EFFECT_TYPE type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::MsgPB::ROLE_EFFECT_TYPE_IsValid(value)) {
            set_type(static_cast< ::MsgPB::ROLE_EFFECT_TYPE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_values;
        break;
      }

      // repeated .MsgPB.KeyVal values = 2;
      case 2: {
        if (tag == 18) {
         parse_values:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_values()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_values;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.AttrEffect)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.AttrEffect)
  return false;
#undef DO_
}

void AttrEffect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.AttrEffect)
  // optional .MsgPB.ROLE_EFFECT_TYPE type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // repeated .MsgPB.KeyVal values = 2;
  for (int i = 0; i < this->values_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->values(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.AttrEffect)
}

::google::protobuf::uint8* AttrEffect::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.AttrEffect)
  // optional .MsgPB.ROLE_EFFECT_TYPE type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // repeated .MsgPB.KeyVal values = 2;
  for (int i = 0; i < this->values_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->values(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.AttrEffect)
  return target;
}

int AttrEffect::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .MsgPB.ROLE_EFFECT_TYPE type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  // repeated .MsgPB.KeyVal values = 2;
  total_size += 1 * this->values_size();
  for (int i = 0; i < this->values_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->values(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AttrEffect::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AttrEffect* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AttrEffect*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AttrEffect::MergeFrom(const AttrEffect& from) {
  GOOGLE_CHECK_NE(&from, this);
  values_.MergeFrom(from.values_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AttrEffect::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AttrEffect::CopyFrom(const AttrEffect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttrEffect::IsInitialized() const {

  return true;
}

void AttrEffect::Swap(AttrEffect* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    values_.Swap(&other->values_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AttrEffect::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AttrEffect_descriptor_;
  metadata.reflection = AttrEffect_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UnderAttack::kMapobjectidFieldNumber;
const int UnderAttack::kDamageFieldNumber;
const int UnderAttack::kCriticlFieldNumber;
const int UnderAttack::kCurrhpFieldNumber;
const int UnderAttack::kTargetSkillFieldNumber;
const int UnderAttack::kDurabilityFieldNumber;
#endif  // !_MSC_VER

UnderAttack::UnderAttack()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.UnderAttack)
}

void UnderAttack::InitAsDefaultInstance() {
}

UnderAttack::UnderAttack(const UnderAttack& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.UnderAttack)
}

void UnderAttack::SharedCtor() {
  _cached_size_ = 0;
  mapobjectid_ = 0;
  damage_ = 0;
  criticl_ = 0;
  currhp_ = 0;
  targetskill_ = 0;
  durability_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnderAttack::~UnderAttack() {
  // @@protoc_insertion_point(destructor:MsgPB.UnderAttack)
  SharedDtor();
}

void UnderAttack::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UnderAttack::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnderAttack::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnderAttack_descriptor_;
}

const UnderAttack& UnderAttack::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

UnderAttack* UnderAttack::default_instance_ = NULL;

UnderAttack* UnderAttack::New() const {
  return new UnderAttack;
}

void UnderAttack::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UnderAttack*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(mapobjectid_, durability_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnderAttack::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.UnderAttack)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mapobjectid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mapobjectid_)));
          set_has_mapobjectid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_damage;
        break;
      }

      // optional int32 damage = 2;
      case 2: {
        if (tag == 16) {
         parse_damage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &damage_)));
          set_has_damage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_criticl;
        break;
      }

      // optional int32 criticl = 3;
      case 3: {
        if (tag == 24) {
         parse_criticl:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &criticl_)));
          set_has_criticl();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_currhp;
        break;
      }

      // optional int32 currhp = 4;
      case 4: {
        if (tag == 32) {
         parse_currhp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currhp_)));
          set_has_currhp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_targetSkill;
        break;
      }

      // optional int32 targetSkill = 5;
      case 5: {
        if (tag == 40) {
         parse_targetSkill:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &targetskill_)));
          set_has_targetskill();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_durability;
        break;
      }

      // optional int32 durability = 6;
      case 6: {
        if (tag == 48) {
         parse_durability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &durability_)));
          set_has_durability();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.UnderAttack)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.UnderAttack)
  return false;
#undef DO_
}

void UnderAttack::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.UnderAttack)
  // optional int32 mapobjectid = 1;
  if (has_mapobjectid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mapobjectid(), output);
  }

  // optional int32 damage = 2;
  if (has_damage()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->damage(), output);
  }

  // optional int32 criticl = 3;
  if (has_criticl()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->criticl(), output);
  }

  // optional int32 currhp = 4;
  if (has_currhp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->currhp(), output);
  }

  // optional int32 targetSkill = 5;
  if (has_targetskill()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->targetskill(), output);
  }

  // optional int32 durability = 6;
  if (has_durability()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->durability(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.UnderAttack)
}

::google::protobuf::uint8* UnderAttack::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.UnderAttack)
  // optional int32 mapobjectid = 1;
  if (has_mapobjectid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->mapobjectid(), target);
  }

  // optional int32 damage = 2;
  if (has_damage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->damage(), target);
  }

  // optional int32 criticl = 3;
  if (has_criticl()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->criticl(), target);
  }

  // optional int32 currhp = 4;
  if (has_currhp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->currhp(), target);
  }

  // optional int32 targetSkill = 5;
  if (has_targetskill()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->targetskill(), target);
  }

  // optional int32 durability = 6;
  if (has_durability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->durability(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.UnderAttack)
  return target;
}

int UnderAttack::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 mapobjectid = 1;
    if (has_mapobjectid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mapobjectid());
    }

    // optional int32 damage = 2;
    if (has_damage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->damage());
    }

    // optional int32 criticl = 3;
    if (has_criticl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->criticl());
    }

    // optional int32 currhp = 4;
    if (has_currhp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currhp());
    }

    // optional int32 targetSkill = 5;
    if (has_targetskill()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->targetskill());
    }

    // optional int32 durability = 6;
    if (has_durability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->durability());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnderAttack::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnderAttack* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnderAttack*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnderAttack::MergeFrom(const UnderAttack& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mapobjectid()) {
      set_mapobjectid(from.mapobjectid());
    }
    if (from.has_damage()) {
      set_damage(from.damage());
    }
    if (from.has_criticl()) {
      set_criticl(from.criticl());
    }
    if (from.has_currhp()) {
      set_currhp(from.currhp());
    }
    if (from.has_targetskill()) {
      set_targetskill(from.targetskill());
    }
    if (from.has_durability()) {
      set_durability(from.durability());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnderAttack::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnderAttack::CopyFrom(const UnderAttack& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnderAttack::IsInitialized() const {

  return true;
}

void UnderAttack::Swap(UnderAttack* other) {
  if (other != this) {
    std::swap(mapobjectid_, other->mapobjectid_);
    std::swap(damage_, other->damage_);
    std::swap(criticl_, other->criticl_);
    std::swap(currhp_, other->currhp_);
    std::swap(targetskill_, other->targetskill_);
    std::swap(durability_, other->durability_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnderAttack::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnderAttack_descriptor_;
  metadata.reflection = UnderAttack_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ItemReward::kItemIDFieldNumber;
const int ItemReward::kItemCountFieldNumber;
#endif  // !_MSC_VER

ItemReward::ItemReward()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.ItemReward)
}

void ItemReward::InitAsDefaultInstance() {
}

ItemReward::ItemReward(const ItemReward& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.ItemReward)
}

void ItemReward::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  itemcount_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemReward::~ItemReward() {
  // @@protoc_insertion_point(destructor:MsgPB.ItemReward)
  SharedDtor();
}

void ItemReward::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ItemReward::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ItemReward::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemReward_descriptor_;
}

const ItemReward& ItemReward::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

ItemReward* ItemReward::default_instance_ = NULL;

ItemReward* ItemReward::New() const {
  return new ItemReward;
}

void ItemReward::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ItemReward*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(itemid_, itemcount_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ItemReward::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.ItemReward)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 ItemID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ItemCount;
        break;
      }

      // optional int32 ItemCount = 2;
      case 2: {
        if (tag == 16) {
         parse_ItemCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemcount_)));
          set_has_itemcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.ItemReward)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.ItemReward)
  return false;
#undef DO_
}

void ItemReward::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.ItemReward)
  // optional int32 ItemID = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // optional int32 ItemCount = 2;
  if (has_itemcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->itemcount(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.ItemReward)
}

::google::protobuf::uint8* ItemReward::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.ItemReward)
  // optional int32 ItemID = 1;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->itemid(), target);
  }

  // optional int32 ItemCount = 2;
  if (has_itemcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->itemcount(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.ItemReward)
  return target;
}

int ItemReward::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 ItemID = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 ItemCount = 2;
    if (has_itemcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemcount());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemReward::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ItemReward* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ItemReward*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ItemReward::MergeFrom(const ItemReward& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_itemcount()) {
      set_itemcount(from.itemcount());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ItemReward::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ItemReward::CopyFrom(const ItemReward& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemReward::IsInitialized() const {

  return true;
}

void ItemReward::Swap(ItemReward* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(itemcount_, other->itemcount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ItemReward::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ItemReward_descriptor_;
  metadata.reflection = ItemReward_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgRepeatedUUID::kUuidFieldNumber;
#endif  // !_MSC_VER

MsgRepeatedUUID::MsgRepeatedUUID()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgPB.MsgRepeatedUUID)
}

void MsgRepeatedUUID::InitAsDefaultInstance() {
}

MsgRepeatedUUID::MsgRepeatedUUID(const MsgRepeatedUUID& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgPB.MsgRepeatedUUID)
}

void MsgRepeatedUUID::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgRepeatedUUID::~MsgRepeatedUUID() {
  // @@protoc_insertion_point(destructor:MsgPB.MsgRepeatedUUID)
  SharedDtor();
}

void MsgRepeatedUUID::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgRepeatedUUID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgRepeatedUUID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgRepeatedUUID_descriptor_;
}

const MsgRepeatedUUID& MsgRepeatedUUID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MsgGameDef_2eproto();
  return *default_instance_;
}

MsgRepeatedUUID* MsgRepeatedUUID::default_instance_ = NULL;

MsgRepeatedUUID* MsgRepeatedUUID::New() const {
  return new MsgRepeatedUUID;
}

void MsgRepeatedUUID::Clear() {
  uuid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgRepeatedUUID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgPB.MsgRepeatedUUID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 uuid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &uuid_)));
          set_has_uuid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgPB.MsgRepeatedUUID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgPB.MsgRepeatedUUID)
  return false;
#undef DO_
}

void MsgRepeatedUUID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgPB.MsgRepeatedUUID)
  // optional int64 uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->uuid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgPB.MsgRepeatedUUID)
}

::google::protobuf::uint8* MsgRepeatedUUID::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgPB.MsgRepeatedUUID)
  // optional int64 uuid = 1;
  if (has_uuid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->uuid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgPB.MsgRepeatedUUID)
  return target;
}

int MsgRepeatedUUID::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->uuid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgRepeatedUUID::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgRepeatedUUID* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgRepeatedUUID*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgRepeatedUUID::MergeFrom(const MsgRepeatedUUID& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgRepeatedUUID::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgRepeatedUUID::CopyFrom(const MsgRepeatedUUID& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgRepeatedUUID::IsInitialized() const {

  return true;
}

void MsgRepeatedUUID::Swap(MsgRepeatedUUID* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgRepeatedUUID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgRepeatedUUID_descriptor_;
  metadata.reflection = MsgRepeatedUUID_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MsgPB

// @@protoc_insertion_point(global_scope)
